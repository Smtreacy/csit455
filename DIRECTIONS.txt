Hi Dr. Hu,

This is the work we have done so far in the application. I'm going to explain to you how to access the source assuming you don't know RoR, so my apologies if you do!
If you are looking for meaningful code, everything you would want to look at will be within the app folder in the root directory (the one this file is in).
The structure should be as follows:

app -
    |-assets
    |   |-config (don't care about)
    |   |-images (don't care about)
    |   |-javascript (don't care about)
    |   |-stylesheets (all the scss file for the app)
    |-channels (don't care about)
    |-controllers
    |   |-admin_controller.rb (logic to perform CRUD operations on the admin side)
    |   |-application_controller.rb (don't care about)
    |   |-books_controller.rb (logic for books)
    |   |-courses_controller.rb (logic for courses)
    |   |-dashboard_controller.rb (the dashboard/middleman for the app logic)
    |   |-teachers_controller.rb (logic for teachers)
    |-helpers (don't care about)
    |-jobs (don't care about)
    |-mailers (don't care about)
    |-models (these are equivalent to SQL contraints for each table)
    |   |-concerns (don't care about)
    |   |-application_record.rb (don't care about)
    |   |-book.rb (constraints on books and internal relationship to courses and media)
    |   |-books_for_classes.rb (constraints for the relational table books_for_classes)
    |   |-course.rb (constraints and internal relationships for courses)
    |   |-teacher.rb (constraints and internal relationships for teachers)
    |-views (actual html -with ruby logic- for the web pages)
        |-admin (pages used for admin)
	|-books (etc..)
	|-courses
	|-dashboard
	|-layouts (default templates that views are placed "into" when being served to client)
	|-teachers

A few other areas to note are the db folder (in the root directory) that contains schema.rb. This file contains the schema for the database that is GENERATED BY RAILS.
We did not make this file! In Rails, you create constraints on data based on the Models, not directly into the schema. This schema file is regenerated every time database
migrations are made. Migrations are edits to the database structure such as adding columns or renaming them in a table. This file does, however, contain the useful information
about the structure internally of the tables. The general syntax is: t.[datatype] "[name of column]" [initial contraints ie. limit 7]. each t.[whatever] defines a column in the table.
At the bottom of the "do end" block is typically the FORIGN KEYS ONLY. Primary keys are assumed by rails and cannot be individually set (easily, that is). Again, these are only the
basic constraints on the database. The rest of the constraints are to be specified in the app/models/[table_name].rb file associated with that table.


Speaking of which, I should explain what the constraint/relationship syntax does to ensure you understand we are doing this right!
Take for example app/models/teacher.rb:

	class Teacher < ApplicationRecord
	  has_many :courses, dependent: :destroy
	  # adds encryption and related security \
	  # checks to teacher passwords
	  has_secure_password

	   # validations to ensure data integrity
	   validates :password, length: { minimum: 6 }, allow_nil: false
	   validates :name, :department, presence: :true
	   validates :email, :format => {:with => /\A\S+@.+\.\S+\z/, :message =>
	      "Please enter a valid email address! ie. john@example.com "}, uniqueness: :true
	end

The "class Teacher < ApplicationRecord" line is just rails saying "this model inherits the attributes of the most basic model you can have" and gives methods for working with the DB.

Next, the line "has_many :courses, depenent: :destroy" creates an internal relationship between Teachers and Courses. This establishes ONE SIDE of the many-to-one relationship (the many side)
if you were to look in courses.rb file (in the same directory) you would find a line "belongs_to :teacher" which establishes the other side of the relationship.
As an aside, belongs_to is similar to has_one, which you might logically expect. belongs_to, however, tells rails to reject the creation of a course if the given teacher does not already exist.
The "dependent: :destroy" part says that if a teacher is deleted from the database, remove all the associated courses as well.

next, the line has_secure_password allows for, you guessed it, a secure password! This hashes the password before storing it in the DB and enforces the confirm password field.

Then we have the validates statements which are, essentially, extended constraints on the data. The syntax is pretty straightforward, and almost reads like actual english.
The general syntax is as follows: validates [:name_of_column(s)], name_of_constraint: :value. To better undestand, lets examine the first validates statement.
"validates :password, length: {minumum: 6}, allow_nil: false"
This reads in english: "validate that the password column is at least 6 characters in length and is not given a null value when creating a new teacher".


Next, lets look at some of the controller syntax! I have yet to fully comment all of the statements with their equivalent SQL statements, but expect this for our final submission!
Take for example an exerpt from the create method to the TeachersController class located in app/controllers/teachers_controller.rb:

...
def create
    # take first and last name given in the form
    f_name = params[:fName].capitalize
    l_name = params[:lName].capitalize
    # concatenate them
    full_name = f_name + ' ' + l_name

    # if passwords match, create new teacher
    # else redirect back
    if params[:su_password] == params[:confirmPass]
      @teacher = Teacher.new({department: params[:department].upcase, name: full_name,
                              email: params[:email], password: params[:su_password],
                              password_confirmation: params[:confirmPass], admin: params[:admin] == 'true' ? true : false})
    else
      # ADD FLASH MESSAGE
      flash[:fail] = "The passwords entered do not match!"
      redirect_back(fallback_location: '/')
      return
    end

    # save new teacher object to rails database
    if @teacher.valid? && @teacher.save
      # redirect home with success message
      flash[:success] = "Account created successfuly!"
      redirect_back(fallback_location: '/')
    else
    ...


so, this is the method responsible for saving (and creatings) new teacher into the database (using the information sent from the teacher/new.html.erb view).
The first portion is just some pre-processing to normalize the input data. What we really want to look at is this statement:

"@teacher = Teacher.new({deppartment: params[:department].upcae, name: full_name ..."

One might expect that this statment actually creates the SQL statement and saves it to the DB, but this is NOT the case!
What this statement actually does is creates a new instance of a Teacher class in the application. At this point, the data is in the class, but NOT the database.
This allows for further testing to be done before inputting potentially wrong data into your database (or saving a blank row if this statement fails).
The actual SQL statement is not executed until @teacher.save in the if conditional statement (and only after we check the validity of the data against our validations).
The equivocal statement might look something like this:

"
begin transaction
  Teacher Exists  SELECT  1 AS one FROM "teachers" WHERE "teachers"."email" = ? LIMIT ?  [["email", "email@example.com"], ["LIMIT", 1]]
  INSERT INTO "teachers" ("department", "name", "email", "password_digest", "admin", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?, ?, ?)  [["department", "ARTH"], ["name", "Joe Jack"], ["email", "email@example.com"], ["password_digest", "$2a$10$CJC7MzLyrdfGEu2IMjHX1e653Pr28VJhJwHc./6QnrNYxzZLQryA6"], ["admin", false], ["created_at", 2017-04-07 14:29:10 UTC], ["updated_at", 2017-04-07 14:29:10 UTC]]
commit transaction
"

What is infinitely great about rails is that is does a lot for you. Rails will automatically wrap every statement in a transaction (with default SQL isolation level) so concurrency
can take place without issue. Rails also checks to see (since we specified in the model that email should be unique) if there is another teacher with the same email.
If so, it will fail and flash a message to the user saying there is already a tuple with that email address (meaning the teacher already has an account).

To see the other SQL statements, just look for statements which use the names of tables in the database (teacher, course, book, etc..). 
A common statement is "@teacher = Teacher.find_by_email(session[:email])". This exexutes a statement similar to "SELECT * FROM "teachers" WHERE email = ?" where ? = email stored in session.
Any statement that uses [Table].[method] generally is checking against the DB (with a few exceptions like we saw).

Running this application will be a problem unless you already have Rails set up on your computer. Rails on Windows is next to impossible to set up and I would never wish that
on my worst enemy haha. In order to see the application working, my group and I would be more than willing to show you in your office using one of our computers! If you are using
Linux by chance, rails is much easier to install (but still a pain) and after installing Rails 5.0.1, all you need to do is execute "rails s" then navigate to
localhost:3000 in your web browser. Again, I don't expect you to be able to run the application, so we will set up a time to show you the app!


That wraps up the summary! If there are any question, email any one of us and we would be more than happy to explain to you whats happening.
Thanks!


Sincerely,

Tyler Roesler
Matt Siragusa
Steven Treacy

